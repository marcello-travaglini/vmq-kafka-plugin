[
  %% Configuration for the vmq_kafka_plugin application
  {vmq_kafka_plugin, [

     %% List of Kafka brokers to connect to.
     %% Each broker is defined as {Host, Port}.
     {brokers, [
        {"localhost", 9092}  %% Local Kafka broker on port 9092
     ]},

     %% Common Kafka client options (applied to both fast and safe clients).
     {client_opts, [
        {client_id_base, "vmq_kafka"},     %% Base prefix for Kafka client IDs
        {request_timeout_ms, 15000}        %% Kafka request timeout in milliseconds
     ]},

     %% Options for the "fast" Kafka client profile.
     %% Optimized for low latency and high throughput, with lower delivery guarantees.
     {fast_opts, [
        {required_acks, 0},                %% Do not wait for broker acknowledgments (fastest)
        {max_batch_size, 131072},          %% Maximum batch size in bytes
        {max_linger_ms, 20},               %% Max time to wait before sending a batch
        {compression, snappy},             %% Use Snappy compression
        {max_retries, 3},                  %% Max number of retries on failure
        {retry_backoff_ms, 100},           %% Delay between retries in milliseconds
        {max_in_flight_requests, 10},      %% Max concurrent in-flight requests
        {queue_buffering_max_messages, 100000}, %% Max messages in the buffer queue
        {queue_buffering_max_kbytes, 1048576}   %% Max buffer size in KB
     ]},

     %% Options for the "safe" Kafka client profile.
     %% Optimized for reliability and exactly-once semantics, with higher latency.
     {safe_opts, [
        {required_acks, -1},               %% Wait for acknowledgments from all replicas
        {enable_idempotence, true},        %% Enable idempotent producer to avoid duplicates
        {max_in_flight_requests, 5},       %% Limit concurrent requests to preserve ordering
        {max_batch_size, 131072},          %% Maximum batch size in bytes
        {max_linger_ms, 20},               %% Max time to wait before sending a batch
        {compression, snappy},             %% Use Snappy compression
        {max_retries, 3},                  %% Max number of retries on failure
        {retry_backoff_ms, 100}            %% Delay between retries in milliseconds
     ]},

     %% Number of concurrent worker processes handling MQTT → Kafka message flow
     {worker_count, 5},

     %% Reusable Kafka header profiles.
     %% Each profile is a map #{BinaryKey => BinaryValue}.
     {headers_profiles,
        #{
           %% Profile for Gateway devices with already standardized messages
           gateway_std =>
              #{
                 <<"device_type">> => <<"Gateway">>,
                 <<"model_type">> => <<"standard">>
              },

           %% Profile for Sensor devices with raw messages requiring modeling
           sensor_raw =>
              #{
                 <<"device_type">> => <<"Sensor">>,
                 <<"model_type">> => <<"raw">>
              }
        }
     },

     %% MQTT → Kafka routing rules.
     %% Each mapping specifies:
     %% - pattern: MQTT topic filter (supports + and # wildcards)
     %% - topic: Kafka destination topic
     %% - headers_profile: name of a profile defined in headers_profiles
     {mappings, [
        #{
          pattern => "gateways/#",         %% Match all topics starting with gateways/
          topic   => "sensor-data",        %% Kafka destination topic
          headers_profile => gateway_std   %% Use the gateway_std header profile
        },
        #{
          pattern => "sensors/+",          %% Match any topic sensors/<something>
          topic   => "sensor-data",        %% Kafka destination topic
          headers_profile => sensor_raw    %% Use the sensor_raw header profile
        }
     ]}
  ]}
].
